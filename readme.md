![单元测试](https://github.com/ddzyan/algorithmAndDataStructure/workflows/Nodejs/badge.svg)

## 简介

记录学习极客时间《数据结构和算法之美》过程中源码实现的数据结构和算法，也会不定时更新每个算法或者数据结构对应的 leetCode 笔试题

## 测试

```sh
$ npm install

$ npm  test
```

## [算法](./algorithm)

- [排序](./algorithm/排序) (复习 16)
  - [x] 插入
  - [x] 冒泡
  - [x] 选择
  - [x] 归并
  - [x] 快排
  - [ ] 桶
  - [ ] 计数
  - [ ] 基数
- [递归](./algorithm/递归)
  - [x] 基础结构
  - [x] 阶梯问题
- [二分查找](./algorithm/二分查找)(复习 3)
  - [x] 在有序不重复的数组中查找指定元素，返回元素下标
  - [x] 查找第一个值等于给定值的元素
  - [x] 查找最后一个值等于给定值的元素
  - [x] 查找第一个大于等于给定值的元素
  - [x] 查找最后一个小于等于给定值的元素
  - [x] 思考题：搜索旋转排序数组
- [字符串匹配](./algorithm/字符串匹配)
  - [x] BF(暴力解法)
  - [ ] RK

## [数据结构](./dataStructure)

- 线性表
  - 顺序表
    - hash 表
      - [x] [源码实现 js Map 对象](./dataStructure/线性表/顺序表/hash表/MyMap.js)
  - 链表
    - [x] [抽象数据类型](./dataStructure/线性表/链表/LinkList)
- 非线性表
  - 树
    - 二叉树
      - [x] [源码实现二叉查找树](./dataStructure/非线性表/树/二叉树/BinarySearchTree.js)
      - [x] q104-二叉树的最大深度
    - Trie 树
      - [x] [源码实现 Trie 树](./dataStructure/非线性表/树/Trie/index.js)
      - [x] 208. 实现 Trie (前缀树)
      - [x] 820. 单词的压缩编码
  - 图
    - [x] [无向图源码实现](./dataStructure/非线性表/图/graph.js)

## 笔记

### 散列表，跳表和红黑树的优缺点

散列表：

- 优点：插入，删除和查找的时间复杂度都为 O(n)，
- 缺点：不支持顺序输出，动态扩容性能消耗较大，需要解决 hash 冲突和 hash 函数性能问题

跳表：

- 优点：插入，删除和查找的时间复杂度都为 log(n)，支持顺序输出
- 缺点：需要额外的存储空间

红黑树

- 优点：插入，删除和查找的时间复杂度都为 log(n)，支持顺序输出
- 缺点：代码实现难

### 如何优化 Trie 树内容占用？

#### 原因

当保存的字符串前缀重复的清空不多的时候，那 Tire 树这种数据结构总体上来讲是比较消耗内存的，这里可以举一个例子：

假设保存的字符串全部都是英文小写字符，则每个子节点需要长度为 26 的数组，每个数组元素都要保存一个 8 字节的指针（这里并不绝对，如何操作系统是 32 位则指针长度为 4），则保存一个子节点需要消耗的内存为 8 \* 26 = 206 个字节。如果保存的字符串不只包含英文小写字符，则保存一个子节点锁消耗的内存则更多。

#### 优化

可以用其他方式来保存子节点数据，例如使用数组，但是不预先保留所有可能结果的位置，而是将字符按照大小顺序插入到数组中，每次查找的时候进行排序比较（可以使用二分查找），但是这样会降低查找效率，因为每次每个节点都需要进行查找，才能找到对应的字符串，这是用空间换时间的一种做法

### Trie 树 , 散列表 和 红黑树 的比较？

Trie 树的缺点：

- 占用空间很大：
  1. 如果字符串中包含的字符集特别多的时候
  2. 如果字符串前缀重复度较低
- 工程上并没有源码实现 Trie 树，需要自己用源码实现，会将问题复杂化
- 保存的方式使用了非线性数据结构，数据块不是连续的，这对 CPU 访问不友好

Trie 适合的场景：不适合做精准匹配
散列表 和 红黑树：更适合做精准匹配
